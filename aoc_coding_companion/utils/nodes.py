from pathlib import Path
from datetime import datetime

from langchain_core.messages import ToolMessage
from langchain_core.runnables.config import RunnableConfig

from aoc_coding_companion.utils.state import AOCState
from aoc_coding_companion.utils.prompts import developer_prompt
from aoc_coding_companion.utils.models import PythonREPL, TaskAnswer
from aoc_coding_companion.utils.tools import run_python_code_with_timeout, ExecTimeoutException
from aoc_coding_companion.utils.constants import DEFAULT_ATTEMPT_COUNT, DEFAULT_TIMEOUT_EXEC_CODE
from aoc_coding_companion.utils.utils import (
    get_model_by_config,
    get_logger_by_config,
    get_parser_by_config,
    get_leaderboard_id_by_config,
    send_telegram_message_by_config
)


async def start_alert(_, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ —Å—Ç–∞—Ä—Ç–µ —Ä–∞–±–æ—Ç—ã')
    comment = f'–û–æ–æ–æ –ø—Ä–∏–≤–µ—Ç! –ï—Ä–∂–∞–Ω üôà –ø—Ä–æ—Å–Ω—É–ª—Å—è –∏ –Ω–∞—á–∞–ª —Ä–∞–±–æ—Ç—É.\n–í—Ä–µ–º—è {datetime.now()}'
    send_telegram_message_by_config(comment, config)
    return {'comment': comment}

start_alert.__name__ = '–û–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ —Å—Ç–∞—Ä—Ç–µ —Ä–∞–±–æ—Ç—ã üëã'


async def check_leader_board(_, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞')
    leaderboard_id = get_leaderboard_id_by_config(config)
    logger.debug(f'–ü–æ–ª—É—á–µ–Ω id –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞ {leaderboard_id}')
    try:
        async with get_parser_by_config(config) as parser:
            logger.debug('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç –ø–∞—Ä—Å–µ—Ä–∞')
            leaderboard_result = await parser.parse_leaderboard(leaderboard_id)
        logger.debug(f'–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞: {leaderboard_result}')
        comment = (
            f'<–ü–†–û–í–ï–†–ö–ê –õ–ò–î–ï–†–ë–û–†–î–ê>: '
            f'–¢–≤–æ–µ –º–µ—Å—Ç–æ - {leaderboard_result.my_position} —Å –æ—á–∫–∞–º–∏ - {leaderboard_result.my_points}'
        )
    except Exception as e:
        comment = f'–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞: {e}'
    send_telegram_message_by_config(comment, config)
    return {'comment': comment}

check_leader_board.__name__ = '–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ø–∏—Å–∫–∞ –ª–∏–¥–µ—Ä–æ–≤ üìä'


async def search_unsolved_puzzles(_, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –ø–æ–∏—Å–∫–∞ –Ω–µ—Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á')
    async with get_parser_by_config(config) as parser:
        logger.debug('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç –ø–∞—Ä—Å–µ—Ä–∞')
        calendar = await parser.parse_calendar()
    logger.debug(calendar)
    comment = (
        f'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ—Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á: {len(calendar.released.unsolved)} '
        f'–∏ —á–∞—Å—Ç–∏—á–Ω–æ –Ω–µ —Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á {len(calendar.released.partially_solved)}'
    )
    send_telegram_message_by_config(comment, config)
    todo_puzzle_links = list(calendar.released.partially_solved.values()) + list(calendar.released.unsolved.values())
    logger.debug(f'–ó–∞–¥–∞—á–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ {todo_puzzle_links}')
    return {'todo_puzzle_links': todo_puzzle_links, 'comment': comment}

search_unsolved_puzzles.__name__ = '–ü–æ–∏—Å–∫ –Ω–µ—Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á üîé'


GET_PUZZLE_ROUTE_NAME = '–ó–∞–¥–∞—á–∏ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –µ—â–µ –µ—Å—Ç—å'
ALL_DONE_ROUTE_NAME = '–í—Å–µ –∑–∞–¥–∞—á–∏ –∏–∑ TODO –ª–∏—Å—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã'


async def route_have_puzzles(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ –≤—ã–±–æ—Ä–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –ø–æ –ø–∞—Ä—Å–∏–Ω–≥—É –∑–∞–¥–∞—á–∏')
    todo_puzzle_links = state.get("todo_puzzle_links", [])
    logger.debug(f'–ó–∞–¥–∞—á–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ {todo_puzzle_links}')
    if len(todo_puzzle_links) > 0:
        return GET_PUZZLE_ROUTE_NAME
    return ALL_DONE_ROUTE_NAME


async def get_puzzle(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –∑–∞–¥–∞—á–∏ –∏ —É—Å–ª–æ–≤–∏–π')
    todo_puzzle_links = state['todo_puzzle_links']
    todo_puzzle_link = todo_puzzle_links.pop(0)
    logger.debug(f'–í–∑—è—Ç–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∑–∞–¥–∞—á—É: {todo_puzzle_link}')
    async with get_parser_by_config(config) as parser:
        logger.debug('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç –ø–∞—Ä—Å–µ—Ä–∞')
        current_puzzle_details = await parser.parse_puzzle_details(todo_puzzle_link)
    comment = (f'–í–∑—è—Ç–æ –≤ —Ä–∞–±–æ—Ç—É:\n{current_puzzle_details}')
    logger.debug(comment)
    send_telegram_message_by_config(comment, config)
    return {
        'todo_puzzle_links': todo_puzzle_links,
        'current_puzzle_details': current_puzzle_details,
        'comment': comment,
        'messages': [],
    }

get_puzzle.__name__ = '–í–∑—è—Ç–∏–µ –∑–∞–¥–∞—á–∏ üëÄ'


async def download_input(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ —Å –≤—Ö–æ–¥–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏')
    working_dir = Path(config['configurable'].get('working_dir', './tmp_work_dir')).resolve()
    logger.debug(f'–†–∞–±–æ—á–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {working_dir}')
    working_dir.mkdir(parents=True, exist_ok=True)
    logger.debug(f'–°–æ–∑–¥–∞–Ω—ã –≤—Å–µ –ø–∞–ø–∫–∏ –ø–æ –ø—É—Ç–∏ {working_dir}')
    current_puzzle_details = state['current_puzzle_details']
    logger.debug(f'–¢–µ–∫—É—â–∞—è –∑–∞–¥–∞—á–∞: {current_puzzle_details}')
    input_filepath = working_dir / f'INPUT({current_puzzle_details.name}).txt'
    logger.debug(f'–ü—É—Ç—å –¥–æ —Ñ–∞–π–ª–∞ {input_filepath}')
    async with get_parser_by_config(config) as parser:
        logger.debug('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç –ø–∞—Ä—Å–µ—Ä–∞')
        await parser.download_input(current_puzzle_details.input_link, input_filepath)
    comment = (f'–°–∫–∞—á–µ–Ω—ã –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–∞–π–ª {input_filepath}')
    logger.debug(comment)
    send_telegram_message_by_config(comment, config)
    return {'input_filepath': input_filepath, 'comment': comment}

download_input.__name__ = '–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö ‚è≥'


async def write_code(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞')
    llm = get_model_by_config(config)
    logger.debug(f'–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç LLM {llm}')
    messages = state.get('messages', [])
    logger.debug(f'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏: {len(messages)}')
    if len(messages) == 0:
        tool_choice = PythonREPL.__name__
    else:
        tool_choice = True
    chain = developer_prompt | llm.bind_tools([PythonREPL, TaskAnswer], tool_choice=tool_choice)

    result = await chain.ainvoke(
        {
            'input_filepath': state['input_filepath'],
            'task_description': state['current_puzzle_details'].description,
            'question': state['current_puzzle_details'].question,
            'messages': messages
        }
    )
    logger.debug(f'–†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏:\n{repr(result)[:100]}')
    messages.append(result)

    if result.tool_calls[0]['name'] == PythonREPL.__name__:
        code = result.tool_calls[0]['args']['query']
        comment = f'–ù–∞–ø–∏—Å–∞–Ω –∫–æ–¥:\n\n{code[:100]}\n...\n'
    else:
        answer = result.tool_calls[0]['args']['answer']
        comment = f'–î–∞–Ω —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ –∑–∞–¥–∞—á—É: {answer}'
    logger.debug(comment)
    send_telegram_message_by_config(comment, config)
    return {'messages': messages, 'comment': comment}


write_code.__name__ = '–ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç üë®üèª‚Äçüíª'


async def exec_code(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –∑–∞–ø—É—Å–∫–∞ –∫–æ–¥–∞')
    tool_calls = state["messages"][-1].tool_calls
    if len(tool_calls) != 1:
        raise ValueError(f'–í—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –±–æ–ª–µ–µ 1.\n{tool_calls}')
    tool_call = tool_calls[0]
    if tool_call['name'] != PythonREPL.__name__:
        raise ValueError(f'–í—ã–∑—ã–≤–∞—é—Ç –Ω–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—é –∫–æ–¥–∞ {PythonREPL.__name__}.\n{tool_call}')
    logger.debug('–ü–æ–ª—É—á–µ–Ω –∫–æ–¥ –¥–ª—è –∑–∞–ø—É—Å–∫–∞')
    try:
        code_output = run_python_code_with_timeout(tool_call['args']['query'], DEFAULT_TIMEOUT_EXEC_CODE).strip(' \n')
    except ExecTimeoutException:
        comment = f'–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è {DEFAULT_TIMEOUT_EXEC_CODE} —Å–µ–∫—É–Ω–¥'
        state['messages'].append(
            ToolMessage(
                content='The code works for more than 2 minutes. '
                        'Check, maybe you made a mistake and there is an infinite loop',
                tool_call_id=tool_call['id']
            )
        )
    else:
        state['messages'].append(ToolMessage(content=code_output, tool_call_id=tool_call['id']))
        comment = f'–†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞: "{code_output}"'
    logger.debug(comment)
    send_telegram_message_by_config(comment, config)
    return {"messages": state['messages'], 'comment': comment}


exec_code.__name__ = '–ó–∞–ø—É—Å–∫ –∫–æ–¥–∞ üöÄ'


EXEC_CODE_ROUTE_NAME = '–¢—Ä–µ–±—É–µ—Ç—Å—è –∑–∞–ø—É—Å–∫ –∫–æ–¥–∞'
FIND_ANSWER_ROUTE_NAME = '–ü–æ–ª—É—á–µ–Ω —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç'


async def route_exec_code(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ –≤—ã–±–æ—Ä–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –ø–æ –∑–∞–ø—É—Å–∫—É –∫–æ–¥–∞')
    tool_calls = state["messages"][-1].tool_calls
    logger.debug(f'–í—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: {tool_calls}')
    if len(tool_calls) == 1 and tool_calls[0]['name'] == PythonREPL.__name__:
        return EXEC_CODE_ROUTE_NAME
    return FIND_ANSWER_ROUTE_NAME


async def answer_submit(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞')

    all_tool_call = [message.tool_calls[0] for message in state['messages']
                            if hasattr(message, 'tool_calls') and
                            len(message.tool_calls) == 1]

    all_tool_call_answer = [tool_call for tool_call in all_tool_call if tool_call['name'] == TaskAnswer.__name__]
    all_tool_call_code = [tool_call for tool_call in all_tool_call if tool_call['name'] == PythonREPL.__name__]
    answers = [tool_call['args']['answer'].strip(' \n') for tool_call in all_tool_call_answer]
    submit_answer = answers.pop(-1)
    logger.debug(f'–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏: {submit_answer}')

    # –ï—Å–ª–∏ —Ç–∞–∫–æ–π –æ—Ç–≤–µ—Ç —Ä–∞–Ω–µ–µ –±—ã–ª
    if submit_answer in answers:
        comment = f'–î–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç —É–∂–µ —Ä–∞–Ω–µ–µ –æ—Ç–≤–µ—á–∞–ª—Å—è –∏ –±—ã–ª –Ω–µ–≤–µ—Ä–Ω—ã–º'
        logger.debug(comment)
        state['messages'].append(
            ToolMessage(
                content=f'The answer is incorrect. You have already answered "{submit_answer}" before. '
                        f'DO NOT REPEAT IT. '
                        f'Reread the terms carefully and try to find the mistake.',
                tool_call_id=all_tool_call_answer[-1]['id']
            )
        )
        return {'messages': state['messages'], 'comment': comment}

    # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
    async with get_parser_by_config(config) as parser:
        logger.debug('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–∫—Ç –ø–∞—Ä—Å–µ—Ä–∞')
        result = await parser.submit_answer(
            state['current_puzzle_details'].submit_url,
            state['current_puzzle_details'].level,
            submit_answer
        )
    logger.debug(f'–û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –†–µ–∑—É–ª—å—Ç–∞—Ç: {result}')
    # –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –≤–µ—Ä–Ω—ã–π
    if result.is_correct:
        final_code = all_tool_call_code[-1]['args']['query']
        comment = f'–û—Ç–≤–µ—Ç "{submit_answer}" –≤–µ—Ä–Ω—ã–π!\n–ö–û–î –î–õ–Ø –†–ï–®–ï–ù–ò–Ø:\n```python\n{final_code}\n```'
        logger.debug(comment)
        send_telegram_message_by_config(comment, config)
        return {'comment': comment}

    # –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π
    comment = f'–û—Ç–≤–µ—Ç "{submit_answer}" –Ω–µ–≤–µ—Ä–Ω—ã–π!\n{result.full_text}'
    state['messages'].append(
        ToolMessage(
            content='The answer is incorrect. '
                    'There is an error somewhere, read the condition again and rewrite the code',
            tool_call_id=all_tool_call_answer[-1]['id']
        )
    )
    logger.debug(comment)
    send_telegram_message_by_config(comment, config)
    return {'messages': state['messages'], 'comment': comment}


answer_submit.__name__ = '–û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ üíå'


async def check_rules_retry(_, config: RunnableConfig):
    # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã –≥—Ä–∞—Ñ–∏–∫–æ–≤
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤–∏–ª –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞')
    return {'comment': '–í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã'}

check_rules_retry.__name__ = '–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤–∏–ª –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ üßê'

MAX_ATTEMPT_NAME = f'–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ ({DEFAULT_ATTEMPT_COUNT})'
RULES_PASSED_NAME = '–í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã'


async def route_check_rules_retry(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ –≤—ã–±–æ—Ä–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤–∏–ª –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞')

    all_tool_call_answer = [message.tool_calls[0] for message in state['messages']
                            if hasattr(message, 'tool_calls') and
                            len(message.tool_calls) == 1 and
                            message.tool_calls[0]['name'] == TaskAnswer.__name__]
    logger.debug(f'–í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: {len(all_tool_call_answer)}')
    if len(all_tool_call_answer) >= DEFAULT_ATTEMPT_COUNT:
        return MAX_ATTEMPT_NAME
    return RULES_PASSED_NAME


async def check_pull_backlog(_, config: RunnableConfig):
    # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã –≥—Ä–∞—Ñ–∏–∫–æ–≤
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—É–ª–∞ –∑–∞–¥–∞—á')
    return {'comment': '–ü—É–ª –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω'}


check_pull_backlog.__name__ = '–ü—Ä–æ—Å–º–æ—Ç—Ä –ø—É–ª–∞ –∑–∞–¥–∞—á üìö'

HAVE_TASKS_NAME = f'–ï—Å—Ç—å –∑–∞–¥–∞—á–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã'
EMPTY_BACKLOG_NAME = '–í—Å–µ –∑–∞–¥–∞—á–∏ –∏–∑ –ø—É–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã'


async def route_check_pull_backlog(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ –≤—ã–±–æ—Ä–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—É–ª–∞ –∑–∞–¥–∞—á')
    todo_puzzle_links = state.get("todo_puzzle_links", [])
    logger.debug(f'–í—Å–µ–≥–æ –∑–∞–¥–∞—á –¥–ª—è —Ä–∞–±–æ—Ç—ã: {len(todo_puzzle_links)}')
    if len(todo_puzzle_links) > 0:
        return HAVE_TASKS_NAME
    return EMPTY_BACKLOG_NAME


RETRY_ROUTE_NAME = '–û—Ç–≤–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π, –ø—Ä–æ–±—É–µ–º –µ—â–µ'
ANSWER_CORRECTNESS_ROUTE_NAME = '–û—Ç–≤–µ—Ç –≤–µ—Ä–Ω—ã–π!'


async def route_answer_correctness(state: AOCState, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ –≤—ã–±–æ—Ä–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –ø–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –æ—Ç–≤–µ—Ç–∞')
    last_message = state['messages'][-1]
    logger.debug(f'–ü–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {last_message}')
    if isinstance(last_message, ToolMessage):
        return RETRY_ROUTE_NAME
    return ANSWER_CORRECTNESS_ROUTE_NAME


async def end_alert(_, config: RunnableConfig):
    logger = get_logger_by_config(config)
    logger.debug('–í—Ö–æ–¥ —É–∑–ª–∞ –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã')
    comment = f'–Ø –∑–∞–∫–æ–Ω—á–∏—Ç—å, –Ω–∞—á–∞–ª—å–Ω–∏–∫–∞!\n–í—Ä–µ–º—è {datetime.now()}'
    send_telegram_message_by_config(comment, config)
    return {'comment': comment}

end_alert.__name__ = '–û–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ –∫–æ–Ω—Ü–µ —Ä–∞–±–æ—Ç—ã üèÅ'
